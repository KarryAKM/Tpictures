# 编译原理

## 第一章 	编译原理概述

![image-20201023110853058](../pictures/image-20201023110853058.png)



区分编译，汇编，翻译，转换程序

![image-20201023111116209](../pictures/image-20201023111116209.png)

翻译程序：同一种机器上的不同语言和不同种机器上的相同或不同语言书写的程序之间都可能需要进行相互翻译，即

把一种语言（源语言，Source Language）书写的程序（源程序，Source Program)翻译为另一种语言（目标语言，Target  Language)书写的程序（目标程序，Target Program)的程序

汇编程序：将汇编语言程序翻译成机器语言程序的程序

编译程序（编译器）：将高级语言程序翻译为对应的低级语言程序（汇编语言或机器语言）的程序

解释程序（解释器）：等同于编译程序，但又有区别

转换程序：能将一种高级语言程序翻译为另一种高级语言程序的程序

![b4ea3ac3a9e47e691799e487597e1d7](../pictures/b4ea3ac3a9e47e691799e487597e1d7.jpg)

图中方框表示不同语言，椭圆框和平行四边形都表示翻译程序（总）

#### 编译过程概述



![image-20201023111205978](../pictures/image-20201023111205978.png)

![image-20201023111723234](../pictures/image-20201023111723234.png)+





![image-20201023111752390](../pictures/image-20201023111752390.png)

## 第二章 文法及其分类

#### 文法的分类

分为4类



1. ** 	**0型文法（无限制文法）****

产生式形式为：α->β，a中至少有一个非终结符



2. **	**1型文法（上下文有关文法）****

∀α->β，| α |≤| β |

产生式形式为：αAβ->αuβ	（u≠ε ）

A只有在α和β这样的上下文环境中才能换成u



3. ​	**2型文法（上下无关文法）**

 产生式形式为：A->β

将A替换成β时，与A的上下文无关



4. ​	**3型文法（正规文法）**	

   右线性文法：产生式形式为：A->aB 或 A->a  

   左线性文法：产生式形式为：A->Ba 或 A->a

![image-20201023114840567](../pictures/image-20201023114840567.png)

#### 句型推导语法树

![image-20201109130723556](../pictures/image-20201109130723556.png)

![image-20201109130744053](../pictures/image-20201109130744053.png)

句型是由文法开始符号加推导出的任一符号串。

句子是由开始符号加推导出的任一**终结**符号串。 

![image-20201023115912314](../pictures/image-20201023115912314.png)



任一子树的树叶全体<u>(具有共同祖先的**叶节点**符号串)</u> 皆为**短语**； 

任一简单子树的树叶全体(<u>具有共同父亲的叶节点符号串</u>)皆为**简单短语**

一个句型的**最左简单短语**称为该句型的句柄

| 名称       | 概念                                                         |
| ---------- | :----------------------------------------------------------- |
| 短语       | **定义：** 若 S 为文法 G 的开始符号，αβδ 是该文法的一个句型，即 S ⇒* αβδ，且有 A ⇒+ β，则称 β 是句型 αβδ 相对于非终结符 A 的短语。**语法树：** 在语法树中表示所有分支结点对应子树，短语即子树叶子对应的符号。**注：** 子树包括语法树本身，及句型本身也可以称为短语。 |
| 简单短语   | **定义：** 若 S ⇒* αβδ，且文法中包含产生式 A → β，则称 β 是句型 αβδ 相对于非终结符 A 的直接短语。**语法树：** 在语法树中表示为该短语只有上下相邻父子两代。任一简单子树的树叶全体(<u>具有共同父亲的叶节点符号串</u>)皆为**简单短语**。  **简单子树**：仅具有单层分支的子树。（记得区分移入-规约分析中的）绿圈为直接短语，最左边的为句柄。![image-20201030113911808](../pictures/image-20201030113911808.png) |
| 句柄       | “可规约串”，句柄对应某个产生式的右部，是某个，但不是任意一个。作为一种规约对象，**句柄表示最左简单短语**。**语法树：** 在语法树上，则表示为最左边的只包含相邻父子节点的短语（最左直接短语） |
| 素短语     | **定义：** 是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语 |
| 最左素短语 | **定义：** 最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象。**语法树：** 通过语法树分析时，要注意先判断是否为素短语，再找相对最左端的素短语。 |

[https://www.cnblogs.com/xpwi/p/11066989.html]()



例题

![image-20201023120311479](../pictures/image-20201023120311479.png)



#### 文法的等价变换

##### 1.文法的等价性

![image-20201023121003870](../pictures/image-20201023121003870.png)





##### 2.删除无用的产生式（文法的化简）

文法的化简是指消除如下无用产生式： 

1.  A->A 形式的产生式(自定己)； 

2. 不能从其推导出终结符号串的产生式(不终结)； 

3.  在推导中永不使用的产生式(不可用)。

   ![image-20201023121634741](../pictures/image-20201023121634741.png)



##### 3.删除ε产生式；

假定文法G(Z); ℇ∈L(G) 

1. 首先构造可以推出空串的非终结符集：V**ℇ** 

① 若有 A->ℇ; 则 令 A∈V**ℇ** ; 

② 若有 B->A1…An且全部 Ai∈V**ℇ** ;则令 B∈V**ℇ** ; 

③ 重复步骤①②，直到V**ℇ** 不再扩大为止。 

2. 删除 G(Z)中的 A -> ℇ形式的产生式； 

3. 依次改写G(Z)中的产生式 B -> X1 X2…Xn : 

若有 Xi∈V**ℇ** 则用 (Xi|ℇ) 替换之(一个分裂为两个)

![image-20201023213855978](../pictures/image-20201023213855978.png)

![image-20201023213921843](../pictures/image-20201023213921843.png)

![image-20201023213946472](../pictures/image-20201023213946472.png)



##### 4.BNF（巴科斯范式）表示法

① 必选项法(园括号法)； 

令 ( α|β ) =α 或者β

例如：有 A -> aα|aβ

可变换成: A -> a(α|β)

也可写成： A -> aA'；A'-> α|β

**注：**此法又称提公因子法，利用此法可以解决：

具有相同左部的各产生式首符号不同！



② 可选项法（方括号法）； 

令 [ α ]  = α 或者 ℇ

例如： S -> α|αβ

可变换成： S -> α[ β ]

也可写成：S -> αS'; S' -> β|ε



③ 重复可选项法（花括号法）

令 { α } = ℇ 或 α 或 αα 或 ααα …

例如： A -> Aβ|α

可变换为： A -> α{β}

也可写成： A→αA' ; A' ->βA'|ℇ



#### 二义性文法

**若对于一个文法的某一句子（或句型），存在两棵不同的语法树，则该文法是二义性文法，否则是无二义性文法。**



## 第三章 词法分析

#### 正则表达式

正则表达式(Regular Expression，RE)是一种用来描述正则语言的** **更紧凑****的表示方法

定义：

![image-20201024111413696](../pictures/image-20201024111413696.png)



![image-20201024111434629](../pictures/image-20201024111434629.png)

可以用RE定义的语言叫做正则语言（正则集合）

![image-20201024112832407](../pictures/image-20201024112832407.png)



![image-20201024112847512](../pictures/image-20201024112847512.png)



#### 有穷自动机及其分类

![image-20201025154452647](../pictures/image-20201025154452647.png)

![image-20201025154514288](../pictures/image-20201025154514288.png)

自动机分为两类

1. **确定的FA**(Deterministic finite automata,**DFA**)
2. **非确定的FA **(Nondeterministic finite automata,**NFA**)

![image-20201025155622442](../pictures/image-20201025155622442.png)



![image-20201025155640580](../pictures/image-20201025155640580.png)

![image-20201025160018349](../pictures/image-20201025160018349.png)



![image-20201025160304898](../pictures/image-20201025160304898.png)

DFA和NFA的区别

1. 对于字母表中的每个符号，DFA中的每个状态都有且只有一条关于这个符号的出边（exiting transition）。NFA则未必，在同一个状态上可能有零条、一条甚至多条关于某一个符号的出边。
2. DFA的转换箭头上的标签必须是字母表中的，但NFA可以有标识为ϵ的边，NFA的状态可能有零条、一条甚至多条ϵ边。

#### 转换

![image-20201025160658258](../pictures/image-20201025160658258.png)

##### （1）有穷自动机**==>**正则文法

![image-20201025160853928](../pictures/image-20201025160853928.png)

![image-20201025160916937](../pictures/image-20201025160916937.png)

在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，**正则文法**是产生式规则取下述形式的一种[形式文法](https://zh.wikipedia.org/wiki/形式文法)（*N*, Σ, *P*, *S*）：

1. *A* -> *a* ，此处的*A*是*N*中的[非终结符号](https://zh.wikipedia.org/w/index.php?title=非终结符号&action=edit&redlink=1)，*a*是Σ中的[终结符号](https://zh.wikipedia.org/w/index.php?title=终结符号&action=edit&redlink=1)；
2. *A* -> *aB*，此处的*A*和*B*是*N*中的非终结符号，*a*是Σ中的终结符号；
3. *C* -> ε，此处的*C*是*N*中的非终结符号。

下面给出一个正则文法的例子： 文法*G* = (*N*, Σ, *P*, *S*)，其中*N* = {S, A}，Σ = {a, b, c}，S是起始符号，*P*包含下述规则：

S -> aS

S -> bA

A -> ε

A -> cA

这个文法描述的语言也可以用[正则表达式](https://zh.wikipedia.org/wiki/正则表达式)a* bc* 来表达。

##### （2）正则文法**==>**有穷自动机M

![image-20201025161128720](../pictures/image-20201025161128720.png)

![image-20201025161241373](../pictures/image-20201025161241373.png)

##### （3）正则式==>有穷自动机

![image-20201025163032977](../pictures/image-20201025163032977.png)

![image-20201025163048440](../pictures/image-20201025163048440.png)

![image-20201025163111080](../pictures/image-20201025163111080.png)

方法一：

![image-20201025163250849](../pictures/image-20201025163250849.png)

![image-20201025163307118](../pictures/image-20201025163307118.png)

![image-20201025163325800](../pictures/image-20201025163325800.png)

分解R的方法有很多种,下面给出另一种分解方式和所构成的 NFA

方法二：

![image-20201025163406884](../pictures/image-20201025163406884.png)

方法三：

![image-20201025164551987](../pictures/image-20201025164551987.png)

![image-20201025164604402](../pictures/image-20201025164604402.png)

![image-20201025164630488](../pictures/image-20201025164630488.png)

例题如下：

![image-20201111201218211](../pictures/image-20201111201218211.png)

![image-20201111201231036](../pictures/image-20201111201231036.png)

![image-20201111201239606](../pictures/image-20201111201239606.png)

![image-20201111201248994](../pictures/image-20201111201248994.png)

![image-20201111201258698](../pictures/image-20201111201258698.png)

![image-20201111201305915](../pictures/image-20201111201305915.png)



##### （4）有穷自动机==>正则式R

##### ![image-20201025164922250](../pictures/image-20201025164922250.png)

![image-20201025165040630](../pictures/image-20201025165040630.png)

![image-20201025165108353](../pictures/image-20201025165108353.png)

##### （5）正则文法==>正则式

![image-20201025165601943](../pictures/image-20201025165601943.png)

![image-20201025165622660](../pictures/image-20201025165622660.png)

##### （6）正则式==>正则文法

![image-20201025165830171](../pictures/image-20201025165830171.png)

##### 补充：DFA的最简化

最简化的DFA：

这个DFA没有**多余状态**，也没有两个**互相等价的状态**。一个DFA可以通过消除**无用状态**、合并等价状态而转换成一个与之等价的最小状态的有穷自动机

![](../pictures/DFA的最简化.jpg)



多余状态：对于一个状态Si来说，若从开始状态出发不可能到达该状态Si，则Si是多余状态。

其中S1,S5,S6就是多余状态

死状态：对于一个状态Si来说，对任意输入符号a，若到达它本身后，不可能从它到达终止状态，则称Si为死状态

其中S2为死状态

无关状态：多余状态和死状态

![image-20201025175950858](../pictures/image-20201025175950858.png)

![image-20201025192724973](../pictures/image-20201025192724973.png)

![image-20201025193504488](../pictures/image-20201025193504488.png)

![image-20201025194048415](../pictures/image-20201025194048415.png)

AC等价，随便选一个进行合并即可

![image-20201109211538354](../pictures/image-20201109211538354.png)

![](../pictures/image-20201025165922147.png)



![image-20201025165957886](../pictures/image-20201025165957886.png)

![image-20201025170009878](../pictures/image-20201025170009878.png)



##### NFA==>DFA

方法一：

通过转换表

![image-20201025200608418](../pictures/image-20201025200608418.png)

![image-20201025200628972](../pictures/image-20201025200628972.png)

初始状态“一致”，在NFA中作为终态的在DFA中状态只要包含都为终态

此方法比较麻烦，因为每次都需要根据输入查表确定状态，不建议使用。



方法二：

子集构造法

![image-20201025201727617](../pictures/image-20201025201727617.png)

同样的例题，把转换好的NFA确定化，图3
![img](../pictures/20180906174352884)

这个表是从NFA到DFA的时候必须要用到的。第一列第一行I的意思是从NFA的起始节点经过任意个ε所能到达的结点集合。Ia表示从该集合开始经过一个a所能到达的集合，经过一个a的意思是可以略过前后的ε。同样Ib也就是经过一个b，可以略过前后任意个ε。
至于第二行以及后面的I是怎么确定的。我参考了一些题目才明白，原来就是看上面的Ia和Ib哪个还没出现在I列，就拿下来进行运算，该列对应的Ia和Ib就是前面我说的那样推导。

###### 重难点 子集构造法注意：

NFA可能有多个终态或者终态有输出，出现此情况就需要添加新的初始状态和新的终结状态

![微信图片_20201111200108](../pictures/微信图片_20201111200108.jpg)

![微信图片_20201111200156](../pictures/微信图片_20201111200156.jpg)

![image-20201111200448872](../pictures/image-20201111200448872.png)

![image-20201111200719688](../pictures/image-20201111200719688.png)



![image-20201025201014733](../pictures/image-20201025201014733.png)

![image-20201025203234428](../pictures/image-20201025203234428.png)

![image-20201025203249455](../pictures/image-20201025203249455.png)

![image-20201025203303248](../pictures/image-20201025203303248.png)

![image-20201025203314898](../pictures/image-20201025203314898.png)

![image-20201025203328835](../pictures/image-20201025203328835.png)

![image-20201025203342982](../pictures/image-20201025203342982.png)

![image-20201025203352434](../pictures/image-20201025203352434.png)

## 第四章 语法分析

#### 语法分析概述

![image-20201111203348076](../pictures/image-20201111203348076.png)

![image-20201111203401625](../pictures/image-20201111203401625.png)

##### 自顶向下分析

分为两类：最右推导、最左推导

tips:在自底向上的分析中，总是采用最左归约的方式，因此把**最左归约**称为**规范归约**，而**最右推导**相应地称为**规范推导**

每一步推导中，都需要做**两个选择**

替换当前句型中的**哪个非终结符**

用该非终结符的**哪个候选式**进行替换

![image-20201111211317516](../pictures/image-20201111211317516.png)



###### 自上而下分析方法中的问题探究及解决方法

![image-20201120084731317](../pictures/image-20201120084731317.png)

![image-20201120084858569](../pictures/image-20201120084858569.png)

![image-20201120085310873](../pictures/image-20201120085310873.png)

![image-20201120085456135](../pictures/image-20201120085456135.png)

![image-20201120090752214](../pictures/image-20201120090752214.png)

![image-20201120090951770](../pictures/image-20201120090951770.png)

![image-20201120091459841](../pictures/image-20201120091459841.png)

![image-20201120091809359](../pictures/image-20201120091809359.png)

![image-20201120092148908](../pictures/image-20201120092148908.png)

![image-20201120092452346](../pictures/image-20201120092452346.png)

由此引入非终结符集的后继符号集Follow

要点：如果A是某个**句型**的最右符号，则将结束符#添加到Follow(A).

FOLLOW集合中不能有ε



根据产生式的可选集构造预测分析表

可选集要点:

**SELECT**(A→aβ **) = {** **a** }

**SELECT**( A→ε )=FOLLOW(A **)** 

<img src="../pictures/image-20201120093441871.png" alt="image-20201120093441871" style="zoom:80%;" />

SELECT集合中不能有ε

![image-20201120093748853](../pictures/image-20201120093748853.png)



示例：

**在计算first集时，先把最左为终结符的进行计算**

**Follow集先看无空，再看空，右看左**

**Select集有或分开算**

![image-20201120103118945](../pictures/image-20201120103118945.png)

![image-20201120103143497](../pictures/image-20201120103143497.png)

![image-20201120103249315](../pictures/image-20201120103249315.png)

第二题

![image-20201122134834867](../pictures/image-20201122134834867.png)

![image-20201122134902554](../pictures/image-20201122134902554.png)

![image-20201122134917232](../pictures/image-20201122134917232.png)



**判断文法是否为LL(1)文法**

![image-20201120104207143](../pictures/image-20201120104207143.png)





![image-20201120104335513](../pictures/image-20201120104335513.png)

![image-20201120104347508](../pictures/image-20201120104347508.png)

![image-20201120104543052](../pictures/image-20201120104543052.png)

M是分析表，A是非终结符，a是输入符号

x![image-20201120104558353](../pictures/image-20201120104558353.png)



##### 自底向上分析

###### 简单优先分析法

![image-20201122210831094](../pictures/image-20201122210831094.png)

![image-20201122232302125](../pictures/image-20201122232302125.png)

![image-20201122232908766](../pictures/image-20201122232908766.png)



**简单优先分析表第一列为左部，第一行为右部，左部为#小于所有符号，右部#大于所有符号(相对称 )**



![image-20201122232407945](../pictures/image-20201122232407945.png)

![image-20201122232501068](../pictures/image-20201122232501068.png)

相同右部无法确定归约哪个文法

![image-20201122210906614](../pictures/image-20201122210906614.png)



###### 算符优先分析法

![image-20201122233550720](../pictures/image-20201122233550720.png)

![image-20201122233534657](../pictures/image-20201122233534657.png)







